"
This models the debugger. It contains the current context and process. Its main goal is to handle debugger actions such as restart or stepInto. It is the model used as an input to GTDebugger.

Instance Variables:
	context	<ContextPart>
	process	<Process>
"
Class {
	#name : #GTDebuggerSession,
	#superclass : #Object,
	#instVars : [
		'context',
		'process'
	],
	#category : #'GT-Debugger'
}

{ #category : #'instance creation' }
GTDebuggerSession class >> process: aProcess [
	^ self new
		process: aProcess
]

{ #category : #'instance creation' }
GTDebuggerSession class >> process: aProcess context: aContext [
	^ self new
		process: aProcess context: aContext
]

{ #category : #'private process' }
GTDebuggerSession >> activePC: aContext [
	^ (self isLatestContext: aContext)
		ifTrue: [ context pc ]
		ifFalse: [ self previousPC: aContext ].
]

{ #category : #private }
GTDebuggerSession >> clear [
	process := nil.
	context := nil
]

{ #category : #accessing }
GTDebuggerSession >> context [
	^ context
]

{ #category : #'private context' }
GTDebuggerSession >> currentCodeRange: aContext [
	^(self methodModel: aContext) sourceRangeForPC: (self activePC: aContext)
]

{ #category : #'private context' }
GTDebuggerSession >> filterTopContext: aContext [
	
	(self shouldDisplayOnTopContext: aContext) ifTrue: [^ aContext].
	self flag: 'limit the number of iterations?'.
	[(aContext := aContext sender) ~~ nil] whileTrue:
		[(self shouldDisplayOnTopContext: aContext) ifTrue: [^ aContext].].
	^ nil
]

{ #category : #accessing }
GTDebuggerSession >> filteredStack [
	"if the global settings are switched of simply return the full stack"
	Debugger filterCommonMessageSends ifFalse: [ ^ self stack ].
	"ask if we should keep each context or not"
	^ self stack select: [ :aContext|
		[self shouldDisplayContext: aContext]
			on: Exception
			do: [ :e| 
				Transcript show: 'Exception occured while filtering context:', context asString; cr;
					show: '------------------------------------------------------'; cr;
					show: e asString; cr;
					show: '------------------------------------------------------'; cr.
				false]]
]

{ #category : #'private process' }
GTDebuggerSession >> isLatestContext: aContext [
	^ process suspendedContext == aContext
]

{ #category : #'private context' }
GTDebuggerSession >> methodModel: aContext [
	^ (GTDebugContext forContext: aContext) topContext: context
]

{ #category : #'private context' }
GTDebuggerSession >> previousPC: aContext [
	^ (aContext method pcPreviousTo: aContext pc)
		ifNil: [ aContext pc ]
]

{ #category : #accessing }
GTDebuggerSession >> process [
	^ process
]

{ #category : #accessing }
GTDebuggerSession >> process: aProcess [
	aProcess stepToSendOrReturn.
	context := aProcess suspendedContext.
	process := aProcess

]

{ #category : #initialization }
GTDebuggerSession >> process: aProcess context: aContext [
	
	aProcess stepToSendOrReturn.
	process := aProcess.
	context := self filterTopContext: aContext.
	context isNil ifTrue: [context := aContext].
	
	"If another context should be displayed on top unwind to that context."
	(aProcess suspendedContext == context) ifFalse: [
		self unwindTo: context. 
		self process stepToSendOrReturn].
	

]

{ #category : #'evaluating actions' }
GTDebuggerSession >> recompileMethodTo: text inContext: recompilationContext [
	| newMethod |				
				
	newMethod := (self methodModel: recompilationContext) recompileCurrentMethodTo: text.
	newMethod isNil 
		ifFalse: [ 
			self rewindContextToMethod: newMethod fromContext: recompilationContext. 
			^ newMethod ] 
		ifTrue: [
			^ nil ]
]

{ #category : #'debugging actions' }
GTDebuggerSession >> restart: selectedContext [
	self unwindTo: selectedContext.
	process
		restartTop;
		stepToSendOrReturn
]

{ #category : #'debugging actions' }
GTDebuggerSession >> resume [
	process resume.
	"self clear."
]

{ #category : #updating }
GTDebuggerSession >> rewindContextToMethod: aMethod fromContext: aContext [
	"this method is typically to be used after a hot compilation of a method from the stack"
	| ctxt |
	ctxt :=  process popTo: aContext.
	
	ctxt == aContext
		ifFalse: [
			self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]
		ifTrue: [
			process
				restartTopWith: aMethod;
				stepToSendOrReturn ].
	
	self flag: 'is it realy necessary to handle quick methods separately?'.
	
	^ context := ctxt
]

{ #category : #accessing }
GTDebuggerSession >> selectedCodeRange: selectedContext [
	^ self currentCodeRange: selectedContext
]

{ #category : #'private context' }
GTDebuggerSession >> shouldDisplayContext: aContext [
	"called by filterStack: on each context to see if it should be displayed 
	in the Debugger view or not."
	|selector receiver|
	selector := aContext method selector.
	receiver := aContext receiver.
	
	"special case for the DoIt selector"
	(receiver class == UndefinedObject and: [selector == #DoIt]) 
		ifTrue: [ ^ true ].
	
	"skip common slectors"
	(#(isNil ifNil: ifNotNil: ifNotNilDo:) includes: selector) 
		ifTrue: [ ^ false ].
	
	"skip sends to kernel classes"
	({Boolean. True. False. BlockClosure. MethodContext. Array. OrderedCollection. Set. IdentitySet. Dictionary. IdentityDictionary. Class. Metaclass. Behavior. SmallInteger. Float. Error. Exception. UndefinedObject} 
		includes: receiver class) 
			ifTrue: [ ^ false ]. 
	
	"skip common message sends to TestCase"
	(((receiver isKindOf: TestCase) 
		and: [TestCase includesSelector: selector])
		and: [(receiver class includesSelector: selector) not])
			ifTrue: [ ^ false ].
			
	"...otherwise display the context"
	^ true
]

{ #category : #'private context' }
GTDebuggerSession >> shouldDisplayOnTopContext: aContext [
	|shouldDisplay|
	
	shouldDisplay := (aContext receiver class = UndefinedObject and: [aContext method selector = #halt ]) not.
	Debugger filterCommonMessageSends ifFalse: [ ^ shouldDisplay ].
	^ shouldDisplay and: [self shouldDisplayContext: aContext].
]

{ #category : #accessing }
GTDebuggerSession >> stack [
	^ context stack
]

{ #category : #accessing }
GTDebuggerSession >> stackOfSize: size [
	^ context stackOfSize: size
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepInto [
	self stepInto: context
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepInto: selectedContext [
	context := process step: selectedContext.
	process stepToSendOrReturn.
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepOver [
	self stepOver: context
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepOver: selectedContext [
	| newContext |
	newContext := process completeStep: selectedContext.
	context := 
		newContext == selectedContext
			ifTrue: [ process stepToSendOrReturn ]
			ifFalse: [ newContext ]
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepThrough [
	self stepThrough: context
]

{ #category : #'debugging actions' }
GTDebuggerSession >> stepThrough: selectedContext [
	"Send messages until you return to the present method context.
	 Used to step into a block in the method."
	
	context := process stepToHome: selectedContext.
	process stepToSendOrReturn.
]

{ #category : #'debugging actions' }
GTDebuggerSession >> terminate [
	self process isNil ifFalse: [self process terminate].
	self clear.
]

{ #category : #private }
GTDebuggerSession >> unwindTo: aContext [
	|ctx|
	ctx := process popTo: aContext.
	ctx == aContext ifFalse: [ self error: 'Could not unwind stack' ].
	context := aContext
]

{ #category : #updating }
GTDebuggerSession >> updateWithContext: newContext fromProcess: aProcess [
	self process: aProcess context: newContext
	 
	"self process: aProcess.
	self unwindTo: (self filterTopContextAndUnwindForContext: newContext).
	self process stepToSendOrReturn."
]
