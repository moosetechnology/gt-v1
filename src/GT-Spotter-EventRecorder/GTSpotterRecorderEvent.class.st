"
GTSpotterRecorderEvent is the root class for representing usage data generated by Spotter. 
All events have a timestamp.
"
Class {
	#name : #GTSpotterRecorderEvent,
	#superclass : #Object,
	#instVars : [
		'timestamp',
		'info'
	],
	#category : #'GT-Spotter-EventRecorder-Events'
}

{ #category : #'instance creation' }
GTSpotterRecorderEvent class >> fromAnnouncement: anAnnouncement [

	^ self new fromAnnouncement: anAnnouncement
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> announcementTimestamp [
	^ self infoAt: #timestamp
]

{ #category : #converting }
GTSpotterRecorderEvent >> associations [
	^ info 
			ifNil: [ #() ]
			ifNotNil: [ info associations ]
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> computerUUID [
	^ self infoAt: #computerUUID
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> eventRecorderVersion [
	^ self infoAt: #eventRecorderVersion
]

{ #category : #accessing }
GTSpotterRecorderEvent >> eventTimestamp [
	^ self timestamp
]

{ #category : #initialization }
GTSpotterRecorderEvent >> fromAnnouncement: anAnnouncement [

	
]

{ #category : #'gt-inspector-extension' }
GTSpotterRecorderEvent >> gtInspectorItems [
	^ OrderedCollection
		 with: (#eventTimestamp -> self timestamp) withAll: self associations
]

{ #category : #'gt-inspector-extension' }
GTSpotterRecorderEvent >> gtInspectorItemsIn: composite [
	<gtInspectorPresentationOrder: -1>  
	^ (composite table)
		title: 'Info';
		display: [ :anEvent | anEvent gtInspectorItems ];
		children: [ :each | 
			(each value isDictionary) 
				ifTrue: [ each value associations ] 
				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])
						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]
						ifFalse: [ #() ] ] ];
		column: 'Key' 
			evaluated: [:each | GTObjectPrinter new asTruncatedTextFrom: each key ];
		column: 'Value' 
			evaluated: [:each | GTObjectPrinter new asTruncatedTextFrom: each value ];
		beMultiple;
		send: [ :selection | 
			(selection notNil and: [ selection size = 1 ]) 
				ifTrue: [ selection anyOne value ] 
				ifFalse: [ selection collect: #value ] ];
		showOnly: 50
]

{ #category : #accessing }
GTSpotterRecorderEvent >> hashForText: aString [
	^ aString hash bitXor: self settings secretUUID hash
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> imageHash [
	^ self infoAt: #imageHash
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> imageVersion [
	^ self infoAt: #imageVersion
]

{ #category : #accessing }
GTSpotterRecorderEvent >> infoAt: key [
	^ self infoAt: key ifAbsent: [ nil ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> infoAt: key ifAbsent: absentBlock [
	info ifNil: [ ^ absentBlock value].
	^ info at: key ifAbsent: absentBlock
]

{ #category : #accessing }
GTSpotterRecorderEvent >> infoAt: key ifPresent: presentBlock ifAbsent: absentBlock [
	info ifNil: [ ^ absentBlock value].
	^ info at: key ifPresent: presentBlock ifAbsent: absentBlock
]

{ #category : #accessing }
GTSpotterRecorderEvent >> infoAt: key put: value [
	info ifNil: [ info := Dictionary new ].
	^ info at: key put: value
]

{ #category : #accessing }
GTSpotterRecorderEvent >> infoAt: key putHashForText: valueString [ 
	^ self 
		infoAt: key 
		put: (self hashForText: valueString)
]

{ #category : #initialization }
GTSpotterRecorderEvent >> initialize [
	super initialize.
	timestamp := Time now asDateAndTime asUnixTime 
]

{ #category : #testing }
GTSpotterRecorderEvent >> isCloseSpotter [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isContextChanged [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isDiveIn [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isDiveOut [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isHidePreview [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isOpenSpotter [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isSearchFinished [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isShowPreview [
	^ false
]

{ #category : #testing }
GTSpotterRecorderEvent >> isUserSelection [
	^ false
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> latestUpdate [
	^ self infoAt: #latestUpdate
]

{ #category : #'accessing - announcement info' }
GTSpotterRecorderEvent >> sessionCreationTime [
	^ self infoAt: #sessionCreationTime
]

{ #category : #accessing }
GTSpotterRecorderEvent >> settings [
	^ GTSpotterEventRecorderSettings uniqueInstance
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringHashesAt: aSymbol [
	^ self 
		infoAt: aSymbol
		ifPresent: [ :array | array first ]
		ifAbsent: [ #() ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringHashesFor: anArrayOrNil [
	^ anArrayOrNil 
			ifNil: [ #() ]
			ifNotNil: [ :array | array first ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringSizesAt: aSymbol [
	^ self 
		infoAt: aSymbol
		ifPresent: [ :array | array second ]
		ifAbsent: [ #() ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringSizesFor: anArrayOrNil [
	^ anArrayOrNil 
			ifNil: [ #() ]
			ifNotNil: [ :array | array second ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringSpecialsAt: aSymbol [
	^ self 
		infoAt: aSymbol
		ifPresent: [ :array | array third ]
		ifAbsent: [ #() ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> stringSpecialsFor: anArrayOrNil [
	^ anArrayOrNil 
			ifNil: [ #() ]
			ifNotNil: [ :array | array third ]
]

{ #category : #accessing }
GTSpotterRecorderEvent >> textInfoFrom: aString [
	| strings hashes sizes specials |
	aString isNil ifTrue: [ ^ nil ].
	aString size isZero ifTrue: [ ^ nil ].
	strings := aString substrings.
	hashes := strings collect: [ :each | self hashForText: each ] as: Array.
	sizes := strings collect: #size as: Array.
	specials := strings collect: [ :each | each beginsWith: '#' ] as: Array.
	^ Array with: hashes with: sizes with: specials 
]

{ #category : #accessing }
GTSpotterRecorderEvent >> timestamp [
	^ timestamp ifNotNil: [ :aTimestamp |
			(DateAndTime fromUnixTime: aTimestamp)
				translateTo: (
					self announcementTimestamp 
						ifNotNil: [ :t | t offset]
						ifNil: [ 0 ]) ] 
]
